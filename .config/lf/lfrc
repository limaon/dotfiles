# vim: ts=2 sts=2 sw=2 ft=conf

set shell bash
set shellopts '-eu'
set ifs "\n"
set info size:time
set sortby natural
set noreverse
set dircounts
set period 1
set autoquit true
set ratios 3:2
set scrolloff 5
set drawbox
set icons
set ignorecase
set incfilter
set incsearch
set tabstop 2
set wrapscroll
set truncatechar "…"
set cleaner "~/.config/lf/exec_cleaner"
set previewer "~/.config/lf/exec_previewer"
set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml"
set timefmt "02/01/2006 15:04:05 "
set infotimefmtnew '02/01 15:04'
set infotimefmtold '02/01/06'
set errorfmt "\033[1;31m"
set numberfmt "\033[38;2;75;87;116m"
set rulerfmt 'df:acc:progress:selection:filter:ind'
set cursorpreviewfmt "\033[7m"


# CMDs/Functions
cmd cfg_reload source ~/.config/lf/lfrc


cmd open ${{
  for f in $fx; do
    # 0 ▶ discard qBittorrent temporary files
    [[ "$f" == *'.!qB' ]] && continue

    # 1 ▶ guard: skip empty files (0 byte) -------------------------------
    if [ ! -s "$f" ]; then
      lf -remote "send $id echo '⚠  Empty file ignored: ${f##*/}'"
      continue
    fi

    # 2 ▶ guard: malformed PDFs -----------------------------------------
    ext="${f##*.}"
    if [[ "${ext,,}" = pdf ]]; then
      if head -c4 -- "$f" | grep -q $'%PDF'; then
        # Authentic PDF → open in reader
        setsid -f zathura "$f" >/dev/null 2>&1 &
      else
        # Missing header → prevent loop and warn
        lf -remote "send $id echo '⚠  Damaged PDF: ${f##*/} — please re‑download the file'"
      fi
      continue                # proceed to next item in the loop
    fi

    # 3 ▶ default MIME detection ----------------------------------------
    mime=$(file --mime-type -Lb -- "$f")
    case "$mime" in
      # spreadsheets
      application/vnd.openxmlformats-officedocument.spreadsheetml.sheet)
        setsid -f localc           "$f" >/dev/null 2>&1 & ;;
      # generic office documents
      text/rtf|application/ms*|application/*office*|*opendocument*|*powerpoint*|application/vnd.ms*)
        setsid -f soffice          "$f" >/dev/null 2>&1 & ;;
      # books and scanned documents
      image/vnd.djvu|application/pdf|application/postscript|application/vnd.djvu|application/epub*)
        setsid -f zathura          "$f" >/dev/null 2>&1 & ;;
      # troff sources
      text/troff)
        man -l -- "$f" ;;
      # plain text, JSON, subtitles
      text/*|application/json|inode/x-empty|application/x-subrip)
        setsid -f "${VISUAL:-$OPENER}" "$f" >/dev/null 2>&1 & ;;
      # images: GIMP, SVG, generic
      image/x-xcf)   setsid -f gimp "$f" >/dev/null 2>&1 & ;;
      image/svg+xml) setsid -f display -- "$f" >/dev/null 2>&1 & ;;
      image/*)       setsid -f lf-select "$f" & ;;
      # audio-only playback
      audio/*|video/x-ms-asf)
        mpv --audio-display=no --force-window=no "$f" ;;
      # video
      video/*|application/vnd.rn-realmedia)
        setsid -f mpv "$f" --quiet >/dev/null 2>&1 & ;;
      # .rar archives
      application/x-rar)
        setsid -f xarchiver        "$f" >/dev/null 2>&1 & ;;
      # encrypted files
      application/pgp-encrypted)
        "${EDITOR:-vi}"            "$f" ;;
      # further office formats
      application/vnd.openxmlformats-officedocument.wordprocessingml.document|\
      application/vnd.oasis.opendocument.text|\
      application/vnd.openxmlformats-officedocument.spreadsheetml.sheet|\
      application/vnd.oasis.opendocument.spreadsheet|\
      application/vnd.oasis.opendocument.spreadsheet-template|\
      application/vnd.openxmlformats-officedocument.presentationml.presentation|\
      application/vnd.oasis.opendocument.presentation-template|\
      application/vnd.oasis.opendocument.presentation|\
      application/vnd.ms-powerpoint|\
      application/vnd.oasis.opendocument.graphics|\
      application/vnd.oasis.opendocument.graphics-template|\
      application/vnd.oasis.opendocument.formula|\
      application/vnd.oasis.opendocument.database)
        setsid -f libreoffice       "$f" >/dev/null 2>&1 & ;;
      # generic binaries – decide by extension
      application/octet-stream)
        case "${f##*.}" in
          doc|docx|xls|xlsx|odt|ppt|pptx) setsid -f libreoffice "$f" >/dev/null 2>&1 & ;;
          ghw)                            setsid -f gtkwave     "$f" >/dev/null 2>&1 & ;;
          ts)                             setsid -f mpv         "$f" --quiet >/dev/null 2>&1 & ;;
          ankiaddon|zip)                  setsid -f xarchiver   "$f" >/dev/null 2>&1 & ;;
          *)                              setsid -f zathura     "$f" >/dev/null 2>&1 & ;;
        esac ;;
      # fallback
      *)
        setsid -f "${OPENER:-xdg-open}" "$f" >/dev/null 2>&1 & ;;
    esac
  done
}}


cmd on-cd %{{
  case "$(basename -- "$PWD")" in
    Downloads|Screenshots)
      lf -remote "send $id set sortby time"
      lf -remote "send $id set reverse"
      ;;
    *)
      lf -remote "send $id set sortby natural"
      lf -remote "send $id set noreverse"
      ;;
  esac
}}


cmd changedirectory ${{
  set -f
  MBASE="/run/media/$(id -un)"
  clear; tput cup $(($(tput lines)/3)); tput bold
  printf 'Go to where?\n'

  dirpath="$(find "$HOME" "$MBASE" -maxdepth 4 -type d 2>/dev/null \
              | fzf --layout=reverse --height 40% --prompt 'Go to where? ')"

  [[ -n "$dirpath" ]] && lf -remote "send $id cd \"$dirpath\""
}}


cmd hard-reload &{{
  [ -d ~/.cache/lf ] && rm -rf ~/.cache/lf
  lf -remote "send $id reload"
}}

cmd yank &{{
  case ${1} in
    dir)  dirname "${f}" ;;
    name) basename "${f}" ;;
    path) printf "%s" "${f}" ;;
  esac | xclip -rmlastnl -selection clipboard
}}

cmd paste &{{
  set -- $(cat ~/.local/share/lf/files)
  mode="$1"
  shift
  dest="$PWD"

  case "$mode" in
    copy)
      NOTIFY_ID=2595
      file_count=$(echo "$@" | wc -w)
      current_file_num=0
      last_percent=-1

      notify-send -r "${NOTIFY_ID}" \
                   -h "int:value:0" \
                   "Copying file(s)..." \
                   "Preparing... ($current_file_num/$file_count)" \
                   -h "string:synchronous:lf-paste" \
                   2>/dev/null

      rsync -aAXHv --info=progress2 --update --no-compress \
            --partial --human-readable \
            -- "$@" . 2>&1 |
      stdbuf -i0 -o0 -e0 tr '\r' '\n' |
      while IFS= read -r line; do
        if echo "$line" | grep -qE '[0-9]+%'; then
          percent=$(echo "$line" | sed -nE 's/.*[[:space:]]+([0-9]+)%[[:space:]].*/\1/p')
          filename=$(echo "$line" | awk '{print $1}' | sed 's|^\./||' | xargs basename 2>/dev/null || echo "file")

          if [ -n "$percent" ] && [ "$percent" -ne "$last_percent" ] && [ "$percent" -gt "$last_percent" ]; then
            if [ "$percent" -eq 100 ] || [ "$((percent - last_percent))" -ge 1 ]; then
              last_percent="$percent"

              if [ "$file_count" -gt 1 ]; then
                total_progress=$(( (current_file_num * 100 + percent) / file_count ))
              else
                total_progress="$percent"
              fi

              notify-send -r "${NOTIFY_ID}" \
                         -h "int:value:${total_progress}" \
                         "Copying file(s)..." \
                         "$filename - $percent% ($(($current_file_num + 1))/$file_count)" \
                         -h "string:synchronous:lf-paste" \
                         2>/dev/null
            fi
          fi

          if [ -n "$percent" ] && [ "$percent" -eq 100 ]; then
            current_file_num=$((current_file_num + 1))
            last_percent=-1
          fi
        fi
      done
      ;;
    move)
      mv -n -- "$@" .
      ;;
  esac

  rm ~/.local/share/lf/files

  if [ "$mode" = "copy" ] && [ -n "${NOTIFY_ID:-}" ]; then
    notify-send -r "${NOTIFY_ID}" "  File(s) pasted." "Pasted to $dest"
  else
    notify-send "  File(s) pasted." "Pasted to $dest"
  fi
  lf -remote "send $id clear"
  lf -remote "send $id reload"
}}

cmd copyto ${{
  set -f
  MBASE="/run/media/$(id -un)"
  clear; tput cup $(($(tput lines)/3))

  dest="$(find "$HOME" "$MBASE" -maxdepth 4 -type d 2>/dev/null \
         | fzf --layout=reverse --height 40% --prompt 'Copy to where? ')"

  [[ -z "$dest" || ! -d "$dest" ]] && exit 1

  clear; tput cup $(($(tput lines)/3)); tput bold
  echo "From:"; printf '%s\n' $fx | sed 's/^/   /'
  printf 'To:\n   %s\n\n\tcopy?[y/N]' "$dest"
  read -r ans
  [[ "$ans" != "y" ]] && exit 1

  NOTIFY_ID=2596
  file_count=$(echo "$fx" | wc -w)
  current_file_num=0
  last_percent=-1

  notify-send -r "${NOTIFY_ID}" \
               -h "int:value:0" \
               "Copying to destination..." \
               "Preparing... ($current_file_num/$file_count)" \
               -h "string:synchronous:lf-copyto" \
               2>/dev/null

  for x in $fx; do
    rsync -aAXHv --info=progress2 --update --no-compress --partial -h \
          --chmod=Du=rwx,Dg=rx,Do=rx,Fu=rw,Fg=r,Fo=r \
          -- "$x" "$dest" 2>&1 |
    stdbuf -i0 -o0 -e0 tr '\r' '\n' |
    while IFS= read -r line; do
      if echo "$line" | grep -qE '[0-9]+%'; then
        percent=$(echo "$line" | sed -nE 's/.*[[:space:]]+([0-9]+)%[[:space:]].*/\1/p')
        filename=$(echo "$line" | awk '{print $1}' | sed 's|^\./||' | xargs basename 2>/dev/null || basename "$x")

        if [ -n "$percent" ] && [ "$percent" -ne "$last_percent" ] && [ "$percent" -gt "$last_percent" ]; then
          if [ "$percent" -eq 100 ] || [ "$((percent - last_percent))" -ge 1 ]; then
            last_percent="$percent"

            if [ "$file_count" -gt 1 ]; then
              total_progress=$(( (current_file_num * 100 + percent) / file_count ))
            else
              total_progress="$percent"
            fi

            notify-send -r "${NOTIFY_ID}" \
                       -h "int:value:${total_progress}" \
                       "Copying to destination..." \
                       "$filename - $percent% ($(($current_file_num + 1))/$file_count)" \
                       -h "string:synchronous:lf-copyto" \
                       2>/dev/null
          fi
        fi

        if [ -n "$percent" ] && [ "$percent" -eq 100 ]; then
          current_file_num=$((current_file_num + 1))
          last_percent=-1
        fi
      fi
    done
  done &&
  notify-send -r "${NOTIFY_ID}" "󰆏  File(s) copied." "File(s) copied to $dest."
  lf -remote 'send clear'
}}


cmd moveto ${{
  set -f
  MBASE="/run/media/$(id -un)"
  clear; tput cup $(($(tput lines)/3))

  dest="$(find "$HOME" "$MBASE" -maxdepth 4 -type d 2>/dev/null \
         | fzf --layout=reverse --height 40% --prompt 'Move to where? ')"

  [[ -z "$dest" || ! -d "$dest" ]] && exit 1

  clear; tput cup $(($(tput lines)/3)); tput bold
  echo "From:"; printf '%s\n' $fx | sed 's/^/   /'
  printf 'To:\n   %s\n\n\tmove?[y/N]' "$dest"
  read -r ans
  [[ "$ans" != "y" ]] && exit 1

  NOTIFY_ID=2597
  file_count=$(echo "$fx" | wc -w)
  current_file_num=0
  last_percent=-1

  notify-send -r "${NOTIFY_ID}" \
               -h "int:value:0" \
               "Moving file(s)..." \
               "Preparing... ($current_file_num/$file_count)" \
               -h "string:synchronous:lf-moveto" \
               2>/dev/null

  for x in $fx; do
    rsync -aAXHv --info=progress2 --update --no-compress --partial -h \
          --chmod=Du=rwx,Dg=rx,Do=rx,Fu=rw,Fg=r,Fo=r \
          -- "$x" "$dest" 2>&1 |
    stdbuf -i0 -o0 -e0 tr '\r' '\n' |
    while IFS= read -r line; do
      if echo "$line" | grep -qE '[0-9]+%'; then
        percent=$(echo "$line" | sed -nE 's/.*[[:space:]]+([0-9]+)%[[:space:]].*/\1/p')
        filename=$(echo "$line" | awk '{print $1}' | sed 's|^\./||' | xargs basename 2>/dev/null || basename "$x")

        if [ -n "$percent" ] && [ "$percent" -ne "$last_percent" ] && [ "$percent" -gt "$last_percent" ]; then
          if [ "$percent" -eq 100 ] || [ "$((percent - last_percent))" -ge 1 ]; then
            last_percent="$percent"

            if [ "$file_count" -gt 1 ]; then
              total_progress=$(( (current_file_num * 100 + percent) / file_count ))
            else
              total_progress="$percent"
            fi

            notify-send -r "${NOTIFY_ID}" \
                       -h "int:value:${total_progress}" \
                       "Moving file(s)..." \
                       "$filename - $percent% ($(($current_file_num + 1))/$file_count)" \
                       -h "string:synchronous:lf-moveto" \
                       2>/dev/null
          fi
        fi

        if [ -n "$percent" ] && [ "$percent" -eq 100 ]; then
          current_file_num=$((current_file_num + 1))
          last_percent=-1
        fi
      fi
    done
    rm -rf -- "$x"
  done &&
  notify-send -r "${NOTIFY_ID}" " File(s) moved." "File(s) moved to $dest."
  lf -remote 'send clear'
}}


# Delete / Trash
# ------------------
cmd delete ${{
    clear; tput cup $(($(tput lines)/3)); tput bold
    set -f
    printf "%s\n\t" "$fx"
    printf "Permenantly delete?[y/N]"
    read ans
    if [ "$ans" = "y" ] && rm -rf -- $fx; then
    notify-send "  File(s) deleted." "$fx"
  fi
}}

cmd trash ${{
  files=$(printf '%s' "$fx" | tr '\n' ';')
  while [ "$files" ]; do
    file=${files%%;*}

    gio trash "$(basename "$file")"
    if [ "$files" = "$file" ]; then
      files=''
    else
      files="${files#*;}"
    fi
  done
}}

cmd clear_trash %gio trash --empty

cmd restore_trash ${{
  gio trash --restore -- "trash:///$(basename -- "$f")"
}}

# Extract / Tar / Zip
# -----------------------
cmd extract ${{
  set -f

  valid_files=""
  invalid_files=""

  for x in $fx; do
    if bsdtar -tf "$x" >/dev/null 2>&1; then
      valid_files="${valid_files}${valid_files:+ }$x"
    else
      base="${x##*/}"
      invalid_files="${invalid_files}${invalid_files:+ }$base"
    fi
  done

  if [ -z "$valid_files" ]; then
    if [ -n "$invalid_files" ]; then
      notify-send -u critical "Not a compressed file" \
                   "No valid archives found to extract" \
                   2>/dev/null
    fi
    exit 0
  fi

  if [ -n "$invalid_files" ]; then
    notify-send -u critical "Some files skipped" \
                 "Invalid archives: $invalid_files" \
                 2>/dev/null
  fi

  clear; tput cup $(($(tput lines)/3)); tput bold
  printf '%s\n' "$valid_files"
  printf 'extract to own folder(s)? [y/N] '
  read -r ans
  [[ "$ans" != "y" ]] && exit 0

  NOTIFY_ID=2598
  file_count=$(echo "$valid_files" | wc -w)
  current_file_num=0

  notify-send -r "${NOTIFY_ID}" \
               -h "int:value:0" \
               "Extracting file(s)..." \
               "Preparing... ($current_file_num/$file_count)" \
               -h "string:synchronous:lf-extract" \
               2>/dev/null

  for x in $valid_files; do
    base="${x##*/}"
    dest="${base%.*}"

    archive_list=$(bsdtar -tf "$x" 2>/dev/null)
    if [ -n "$archive_list" ]; then
      first_entry=$(echo "$archive_list" | head -1)
      root_dir=$(echo "$first_entry" | cut -d'/' -f1)

      first_is_dir=$(echo "$first_entry" | grep -q '/$' && echo "yes" || echo "no")

      has_files_in_root="no"
      all_in_same_root="yes"

      for entry in $archive_list; do
        [ -z "$entry" ] && continue

        if ! echo "$entry" | grep -q '/'; then
          has_files_in_root="yes"
          all_in_same_root="no"
          break
        fi

        entry_root=$(echo "$entry" | cut -d'/' -f1)

        if [ "$entry_root" != "$root_dir" ]; then
          all_in_same_root="no"
          break
        fi
      done

      if [ "$all_in_same_root" = "yes" ] && [ "$first_is_dir" = "yes" ] && [ "$has_files_in_root" = "no" ]; then
        extract_dest="."
        saved_root_dir="$root_dir"
      else
        mkdir -p -- "$dest" || continue
        extract_dest="$dest"
        saved_root_dir=""
      fi
    else
      mkdir -p -- "$dest" || continue
      extract_dest="$dest"
      saved_root_dir=""
    fi

    archive_size=$(stat -f%z "$x" 2>/dev/null || stat -c%s "$x" 2>/dev/null || echo 0)

    if command -v pv >/dev/null 2>&1 && [ "$archive_size" -gt 0 ]; then
      pv -s "$archive_size" -p -t -e "$x" | bsdtar -xf - -C "$extract_dest" 2>/dev/null |
      while IFS= read -r line; do
        if echo "$line" | grep -qE '[0-9]+%'; then
          percent=$(echo "$line" | sed -nE 's/.*[[:space:]]*\(([0-9]+)%\)[[:space:]]*.*/\1/p' | head -1)
          if [ -z "$percent" ]; then
            percent=$(echo "$line" | sed -nE 's/.*[[:space:]]+([0-9]+)%[[:space:]].*/\1/p' | head -1)
          fi

          if [ -n "$percent" ] && [ "$percent" -ge 0 ] && [ "$percent" -le 100 ]; then
            total_progress=$(( (current_file_num * 100 + percent) / file_count ))
            notify-send -r "${NOTIFY_ID}" \
                       -h "int:value:${total_progress}" \
                       "Extracting file(s)..." \
                       "$base - $percent% ($(($current_file_num + 1))/$file_count)" \
                       -h "string:synchronous:lf-extract" \
                       2>/dev/null
          fi
        fi
      done
    else
      initial_size=$(du -sb "$extract_dest" 2>/dev/null | awk '{print $1}' || echo 0)

      bsdtar -xf "$x" -C "$extract_dest" &
      tar_pid=$!

      while kill -0 "$tar_pid" 2>/dev/null; do
        current_size=$(du -sb "$extract_dest" 2>/dev/null | awk '{print $1}' || echo 0)

        if [ "$archive_size" -gt 0 ]; then
          extracted_bytes=$((current_size - initial_size))
          percent=$(( (extracted_bytes * 100) / archive_size ))
          [ "$percent" -gt 100 ] && percent=100
        else
          percent=50
        fi

        total_progress=$(( (current_file_num * 100 + percent) / file_count ))
        notify-send -r "${NOTIFY_ID}" \
                   -h "int:value:${total_progress}" \
                   "Extracting file(s)..." \
                   "$base - $percent% ($(($current_file_num + 1))/$file_count)" \
                   -h "string:synchronous:lf-extract" \
                   2>/dev/null

        sleep 0.5
      done
      wait "$tar_pid"
    fi

    if [ "$extract_dest" != "." ]; then
      find "$extract_dest" -type f -exec chmod -x -- {} +
    elif [ -n "$saved_root_dir" ] && [ -d "$saved_root_dir" ]; then
      find "$saved_root_dir" -type f -exec chmod -x -- {} +
    fi
    current_file_num=$((current_file_num + 1))

    total_progress=$(( (current_file_num * 100) / file_count ))
    notify-send -r "${NOTIFY_ID}" \
               -h "int:value:${total_progress}" \
               "Extracting file(s)..." \
               "$base - 100% ($current_file_num/$file_count)" \
               -h "string:synchronous:lf-extract" \
               2>/dev/null
  done

  notify-send -r "${NOTIFY_ID}" "󰏖  Extracted." "Unpacked to individual folders."
  lf -remote 'send reload'
}}

cmd tar ${{
  clear; tput cup $(($(tput lines)/3)); tput bold
  printf "Archive Name: "
  read archive_name
  set -f
  tar -czvf "${archive_name}.tar.gz" -C "$(dirname "$f")" $(basename -a -- $fx)
}}

cmd zip-files ${{
  printf "Enter zip archive name: "
  read name
  unset files
  printf '%s\n' $fx | while read -r l; do zip -r "$name" "$(basename -- "$l")"; done
  clear
}}

cmd touch-file ${{
  clear; tput cup $(($(tput lines)/3)); tput bold
  printf "File name: "
  read name
  touch "$name"
  clear
}}

cmd mkdir ${{
  clear; tput cup $(($(tput lines)/3)); tput bold
  set -f
  printf "%s\n\t" "$fx"
  printf "Folder name: "
  read newd
  mkdir -- "$newd"
  # mv -- $fx "$newd"
}}

cmd fzf_jump ${{
  res="$(find . 2>/dev/null -maxdepth 6 | fzf --bind tab:down,shift-tab:up --reverse --header='Jump to location')"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}

# | Permissions (chmod/chown) |
# -----------------------------
cmd chmod ${{
  clear; tput cup $(($(tput lines)/3)); tput bold
  set -f
  printf "%s\n\t" "$fx"
  printf "chmod: "
  read ans

  for file in $fx; do
    chmod "$ans" "$file"
  done

  lf -remote 'send reload'
  lf -remote 'send clear'
}}

cmd chown ${{
  clear; tput cup $(($(tput lines)/3)); tput bold
  set -f
  printf "%s\n\t" "$fx"
  printf "chown: "
  read ans

  for file in $fx; do
    sudo chown "$ans" "$file"
  done

  lf -remote 'send reload'
  lf -remote 'send clear'
}}

cmd file-type ${{
  file -i "$f" ; read a
  clear
}}

cmd bulk-rename ${{
  old="$(mktemp)"
  new="$(mktemp)"
  if [ -n "$fs" ]; then
    fs="$(basename -a $fs)"
  else
    fs="$(ls)"
  fi
  printf '%s\n' "$fs" >"$old"
  printf '%s\n' "$fs" >"$new"
  $EDITOR "$new"
  [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
  paste "$old" "$new" | while IFS= read -r names; do
  src="$(printf '%s' "$names" | cut -f1)"
  dst="$(printf '%s' "$names" | cut -f2)"
  if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
    continue
  fi
  mv -- "$src" "$dst"
  done
  rm -- "$old" "$new"
  lf -remote "send $id unselect"
}}

cmd stop ${{
  kill -TSTP "$(ps -p $$ -o 'ppid=')"
}}


cmd ud-unmount ${{
    if udiskie-umount -aef; then
        lf -remote "send $id echomsg >> The device was umounted <<"
    else
        lf -remote "send $id echoerr >> udiskie-umount failed <<"
    fi
}}

cmd setbg ${{
  case "$(file --mime-type -Lb "$f")" in
    image/*)  setsid -f setbg "$f" >/dev/null 2>&1 ;;
    *)        lf -remote "send $id echoerr «not an image»" ;;
  esac
}}

cmd select-glob &{{
    select_glob() {
        files="$(printf '%s\0' "$@" | sed 's/ /\\ /g;s/\x00/ /g')"
        lf -remote "send $id :unselect; toggle $files"
    }

    [ "$#" -eq 1 ] || exit

    # enable recursive glob and failglob
    shopt -s globstar failglob

    select_glob $1
}}

cmd go_to_current_song ${{
	music_dir=$( grep -Po 'music_directory\s*"\K.*(?="$)' ~/.config/mpd/mpd.conf )
	playing_file=$( mpc -f %file% | head -1 )
	lf -remote " send $id select '${music_dir}/${playing_file}' "
}}

# Key maps
#---------

map m
map "'"
map '"'
map t
map c
map r
map w
map o

# Search
map f
map ff find
map fb find-back
map fF :fzf_jump

#General maps
map cd changedirectory
map mf touch-file
map md mkdir
map R :redraw; reload; recol; cfg_reload
map r :redraw; reload; clear;
map <esc> :redraw; reload; clear;
map <c-r> hard-reload
map zp set preview!
map zd set dirfirst!
map sn :set sortby natural; set reverse!; set info size
map se :set sortby ext; set reverse!; set info size
map w setbg

# Archive Mappins
map xz zip-files
map xt tar
map xx extract

# Delete files
map d
map dd cut
map df moveto
map dD delete
map <delete> delete
map dt trash
map dc clear_trash
map dr restore_trash

map p
map p paste

map chmod chmod
map chown chown

# Copy
map y
map yy copy
map yf copyto
map yp yank path
map yn yank name
map yd yank dir
map Y file-type

# Rename
map <f-2> rename
map A rename
map i push A<c-u>
map I push A<c-a>
map a push A<a-b>
map B bulk-rename

# Some movements
map { half-up
map } half-down
map <enter> open

# Movement dirs
map g/ cd /
map gM cd /mnt
map ge cd /etc
map gP cd /tmp
map gU cd /usr
map gd cd ~/Desktop
map gD cd ~/Downloads
map gp cd ~/Pictures
map gm cd ~/Music
map gV cd ~/Videos
map gC cd ~/.config
map gL cd ~/.local
map gr $lf -remote "send $id cd /run/media/$(id -un)"
map gs go_to_current_song
map gtr cd ~/.local/share/Trash/files
map gb cd /usr/share/backgrounds
map gu ud-unmount
