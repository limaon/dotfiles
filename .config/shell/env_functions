# Usage: indirect_expand VARIABLE_NAME
# Expands the value of the specified environment variable indirectly.
# Example: indirect_expand PATH
indirect_expand() {
    env | sed -n "s/^$1=//p"
}

# Usage: pathremove /path/to/bin [VARIABLE_NAME]
# Removes the specified directory from the given PATH variable (default is PATH).
# Example: pathremove ~/bin PATH
pathremove() {
    local IFS=':'
    local newpath
    local dir
    local var=${2:-PATH}
    # Bash has ${!var}, but this is not portable.
    for dir in $(indirect_expand "$var"); do
        IFS=''
        if [ "$dir" != "$1" ]; then
            newpath=$newpath:$dir
        fi
    done
    export "$var"="${newpath#:}"
}

# Usage: pathprepend /path/to/bin [VARIABLE_NAME]
# Prepends the specified directory to the given PATH variable (default is PATH).
# Example: pathprepend ~/bin PATH
pathprepend() {
    # Remove the path if it already exists to move it to the front
    pathremove "$1" "$2"
    # [ -d "${1}" ] || return
    local var
    var="${2:-PATH}"
    local value
    value=$(indirect_expand "$var")
    export "${var}"="${1}${value:+:${value}}"
}

# Usage: pathappend /path/to/bin [VARIABLE_NAME]
# Appends the specified directory to the given PATH variable (default is PATH).
# Example: pathappend ~/bin PATH
pathappend() {
    pathremove "${1}" "${2}"
    #[ -d "${1}" ] || return
    local var
    var=${2:-PATH}
    local value
    value=$(indirect_expand "$var")
    export "$var"="${value:+${value}:}${1}"
}

# Usage: ssource filename
# Sources the specified file if it is readable.
# Example: ssource myscript.sh
ssource() {
    if [ -r "$1" ]; then
        # shellcheck disable=SC1090
        . "$1"
    fi
}

# Usage: mkcd directory_name
# Creates a directory and changes into it.
# Example: mkcd new_folder
mkcd() {
    mkdir -p "$1"
    cd "$1" || exit
}

# Usage: remorphans
# Uninstalls all orphaned packages (packages no longer required as dependencies).
remorphans() {
    local packages=()
    local package

    while IFS= read -r package; do
        packages+=("$package")
    done < <(pacman -Qdtq)

    echo "Found ${#packages[*]} orphans."
    if ! [[ ${#packages[*]} -eq 0 ]]; then
        sudo pacman -Rns "${packages[@]}"
    fi
}

# Usage: lf [options]
# Launches the lf file manager and returns to the last visited directory after exit.
lfcd () {
  local dir
  dir="$(command lf -print-last-dir "$@")"
  [ -n "$dir" ] && [ -d "$dir" ] && cd -- "$dir"
}

### FZF functions and options
FZF_EXCLUDE_DIRS=(
    # Common unnecessary directories
    ".git"
    "node_modules"
    ".cache"
    ".cargo"
    ".yarn"
    ".svn"
    # Python-specific non-relevant files and folders
    "__pycache__"
    "*.pyc"
    "*.pyo"
    "*.pyd"
    "*.egg-info"
    "*.eggs"
    ".env"
    ".venv"
    "env"
    "venv"
    ".mypy_cache"
    ".pytest_cache"
    ".tox"
    ".coverage"
    ".hypothesis"
    ".idea"
    ".ropeproject"
    "*.log"
    "*.db"
    "pip-selfcheck.json"
    # Media and binary assets
    "*.png"
    "*.mp4"
    "*.mp3"
    "*.jpg"
    "*.jpeg"
    "*.bin"
    "*.svg"
    "*.gz"
    "*.tar"
    "*.tgz"
    "*.zip"
    # Swap and temporary files
    "*/.swap*"
    "*.swp"
    "*.swo"
    "*.swm"
    "*.swn"
    "*.swo"
    "*.swl"
    "*.spp"
    # Irrelevant/large files and folders often found in $HOME/.config
    ".DS_Store"
    ".Trash"
    "*.lock"
    "*.sqlite"
    "*.log"
    "Cache"
    "cache"
    ".local"
    "*.bak"
    ".recently-used"
    "Code/CachedData"
    "Code/Crashpad"
    "Code/logs"
    "Code/Service Worker/CacheStorage"
    "google-chrome"
    "chromium"
    "BraveSoftware"
    "VSCodium"
    "Electron"
    "kitty/session"
    "nvim/backup"
    "nvim/swap"
    "nvim/shada"
    "nvim/undo"
    "btop/themes"
    "btop/logs"
    # Irrelevant/large files and folders often found in $HOME/.local
    ".local/share/Trash"
    ".local/share/flatpak"
    ".local/share/baloo"
    ".local/share/Steam"
    ".local/share/akonadi"
    ".local/share/recently-used.xbel"
    ".local/share/nvim/backup"
    ".local/share/nvim/swap"
    ".local/share/nvim/shada"
    ".local/share/nvim/undo"
    ".local/share/virtualenvs"
    ".local/share/gnome-shell"
    ".local/share/gvfs-metadata"
    ".local/share/gvfs-metadata/*"
    ".local/share/Trash/*"
    ".local/share/containers"
    ".local/state"
    ".local/cache"
    ".local/log"
    ".local/bin/__pycache__"
    ".local/bin/*.pyc"
)
if command -v fd >/dev/null 2>&1; then
    FZF_CMD='fd --type f --hidden --follow'
    for dir in "${FZF_EXCLUDE_DIRS[@]}"; do
        FZF_CMD="$FZF_CMD --exclude \"$dir\""
    done
    export FZF_DEFAULT_COMMAND="$FZF_CMD"
elif command -v rg >/dev/null 2>&1; then
    FZF_CMD='rg --files --hidden --follow'
    for dir in "${FZF_EXCLUDE_DIRS[@]}"; do
        FZF_CMD="$FZF_CMD --glob \"!$dir/*\""
    done
    export FZF_DEFAULT_COMMAND="$FZF_CMD"
else
    FZF_CMD='find . -type f'
    for dir in "${FZF_EXCLUDE_DIRS[@]}"; do
        FZF_CMD="$FZF_CMD -not -path \"*/$dir/*\""
    done
    export FZF_DEFAULT_COMMAND="$FZF_CMD"
fi
export FZF_DEFAULT_OPTS="--height 40% --layout=reverse --border"

# Usage: locatefall
# Uses fzf to locate a file in the current directory and changes into it if it's a directory, or opens it in the editor if it's a file.
fall() {
    local file
    local dir
    dir="$(pwd)"
    file=$(locate "${dir}/" 2>/dev/null | fzf-tmux -p +m) && if [ -d "$file" ]; then cd "$file" || exit; else ${EDITOR:-vim} "$file"; fi
}


# Usage: fe
# Finds and edits a file in the current directory, excluding certain paths and file types.
fe() {
    local file

    if [ -n "$FZF_DEFAULT_COMMAND" ]; then
        file="$($FZF_DEFAULT_COMMAND 2>/dev/null | fzf-tmux -p +m)"
    else
        file="$( find . \
            -type f \
            -not \( \
                -path "*/.git*" -o \
                -path "*/.cache*" -o \
                -path "*/.cargo*" -o \
                -path "*/.yarn*" -o \
                -path "*/chromium*" -o \
                -path "*/.svn*" -o \
                -path "*.png" -o \
                -path "*.mp4" -o \
                -path "*.mp3" -o \
                -path "*.jpg" -o \
                -path "*.jpeg" -o \
                -path "*.bin" -o \
                -path "*.svg" -o \
                -path "*.gz" -o \
                -path "*.tar" -o \
                -path "*.tgz" -o \
                -path "*.zip" \
            \) \
            ! -size 0 \
            -print 2> /dev/null | fzf-tmux -p +m)"
    fi

    [ -n "$file" ] && ${EDITOR:-vim} "$file"
}


# Usage: fcd
# Changes to a directory selected via fzf, excluding certain paths.
fcd() {
    local dir
    dir=$(find . \
        -not \( -path "*/.*" -prune \) \
            -not \( -path "*/Library/*" -prune \) \
            -not \( -path "*/Applications/*" -prune \) \
            -not \( -ipath "*/cache/*" -prune \) \
        -type d -print 2> /dev/null | fzf-tmux -p +m) &&
    cd "$dir" || return
}

# Usage: fkill [signal]
# Kills processes selected via fzf. Default signal is SIGKILL (9).
fkill() {
    local pids
    pids=$(ps -ef | sed 1d | fzf-tmux -p -m | awk '{print $2}')
    [ -n "$pids" ] && echo "$pids" | xargs kill "-${1:-9}"
}

# Usage: fps
# Displays currently running processes using fzf for selection.
fps() {
    ps aux | sed 1d | fzf-tmux -p -m
}

# Usage: fhist
# Searches command history using fzf.
fhist() {
    local cmd
    cmd=$(history | awk '{$1=""; sub(/^[ \t]*[0-9-]+[ \t]+([0-9:]+[ \t]+)?/, ""); print}' |
          fzf-tmux -p +s --tac)
    [[ -z $cmd ]] && return
    history -s "$cmd"
    printf '%s\n' "$cmd"
}


_replace_slash_with_semicolon() {
    local line=${READLINE_LINE}
    local pos=${READLINE_POINT}
    if [ $pos -gt 0 ] && [ "${line:$((pos-1)):1}" = "/" ]; then
        READLINE_LINE="${line:0:pos-1};${line:pos}"
        READLINE_POINT=$((pos))
    else
        READLINE_LINE="${line:0:pos};${line:pos}"
        READLINE_POINT=$((pos+1))
    fi
}
[[ $- == *i* ]] && bind -x '"\;": _replace_slash_with_semicolon'

# vim:ft=sh
