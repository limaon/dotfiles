#!/usr/bin/env bash
CONFIG_FILE_NAME="tmux-sessionizer.conf"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/tmux-sessionizer"
CONFIG_FILE="$CONFIG_DIR/$CONFIG_FILE_NAME"
PANE_CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/tmux-sessionizer"
PANE_CACHE_FILE="$PANE_CACHE_DIR/panes.cache"

# ═══════════════════════════════════════════════════════════════════════════════
# CONFIG FILE EXAMPLE: ~/.config/tmux-sessionizer/tmux-sessionizer.conf
# ═══════════════════════════════════════════════════════════════════════════════
#
# ┌────────────────────────────────────────────────────────────────────────────┐
# │ SEARCH PATHS                                                               │
# └────────────────────────────────────────────────────────────────────────────┘
#
# TS_SEARCH_PATHS:
#   Override default search paths (~/ ~/personal ~/personal/dev/env/.config)
#   Example: TS_SEARCH_PATHS=(~/ ~/projects ~/work ~/personal)
#
# TS_EXTRA_SEARCH_PATHS:
#   Add additional search paths without replacing defaults
#   Suffix :N defines search depth (optional)
#   Example: TS_EXTRA_SEARCH_PATHS=(~/ghq:3 ~/Git:3 ~/.config:2)
#
# TS_MAX_DEPTH:
#   Default max depth for paths without :N suffix (default: 1)
#   Example: TS_MAX_DEPTH=2
#
# ┌────────────────────────────────────────────────────────────────────────────┐
# │ SESSION COMMANDS (Isolated Windows)                                        │
# └────────────────────────────────────────────────────────────────────────────┘
#
# Creates windows at indices 69, 70, 71... to avoid interfering
# with normal workflow of first 10 windows
#
# Usage:
#   tmux-sessionizer -s 0  → window 69 (first command)
#   tmux-sessionizer -s 1  → window 70 (second command)
#
# Example:
#   TS_SESSION_COMMANDS=(
#       "nvim"                    # Index 0 → window 69
#       "htop"                    # Index 1 → window 70
#       "lazydocker"              # Index 2 → window 71
#   )
#
# With splits (reusable panes):
#   tmux-sessionizer -s 0 --vsplit  # Vertical split (horizontal layout)
#   tmux-sessionizer -s 1 --hsplit  # Horizontal split (vertical layout)
#
# ┌────────────────────────────────────────────────────────────────────────────┐
# │ LOGGING                                                                    │
# └────────────────────────────────────────────────────────────────────────────┘
#
# TS_LOG:
#   echo    - Print logs to terminal (useful for debugging)
#   file    - Save logs to file
#   empty   - Disable logging (default)
#
# TS_LOG_FILE:
#   Log file path (default: ~/.local/share/tmux-sessionizer/tmux-sessionizer.logs)
#
# Example:
#   TS_LOG=file
#   TS_LOG_FILE="$HOME/.local/share/tmux-sessionizer/tmux-sessionizer.logs"
#
# ┌────────────────────────────────────────────────────────────────────────────┐
# │ COMPLETE EXAMPLE                                                           │
# └────────────────────────────────────────────────────────────────────────────┘
#
# TS_SEARCH_PATHS=(~/Desktop)
# TS_EXTRA_SEARCH_PATHS=(~/.local:1 ~/.config:1)
# TS_MAX_DEPTH=1
# TS_REPO_CLONE_DIR=~/Desktop
# TS_SESSION_COMMANDS=("nvim" "htop")
# TS_LOG=file | echo
# ═══════════════════════════════════════════════════════════════════════════════

if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
fi

if [[ -f "$CONFIG_FILE_NAME" ]]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE_NAME"
fi

if [[ $TS_LOG != "true" ]]; then
    if [[ -z $TS_LOG_FILE ]]; then
        TS_LOG_FILE="$HOME/.local/share/tmux-sessionizer/tmux-sessionizer.logs"
    fi

    mkdir -p "$(dirname "$TS_LOG_FILE")"
fi

log() {
    if [[ -z $TS_LOG ]]; then
        return
    elif [[ $TS_LOG == "echo" ]]; then
        echo "$*"
    elif [[ $TS_LOG == "file" ]]; then
        echo "$*" >> "$TS_LOG_FILE"
    fi
}

session_idx=""
session_cmd=""
user_selected=""
split_type=""
lifecycle_action=""
create_target=""
rename_target=""
delete_target=""
VERSION="0.1.0"

set_lifecycle_action() {
    local action="$1"
    if [[ -n "$lifecycle_action" && "$lifecycle_action" != "$action" ]]; then
        echo "Error: --create, --rename, and --delete cannot be combined"
        exit 1
    fi
    lifecycle_action="$action"
}

while [[ "$#" -gt 0 ]]; do
    case "$1" in
    -h | --help)
        echo "Usage: tmux-sessionizer [OPTIONS] [SEARCH_PATH]"
        echo "Options:"
        echo "  -h, --help             Display this help message"
        echo "  -v, --version          Display version"
        echo "  -s, --session <name>   session command index."
        echo "  --vsplit               Create vertical split (horizontal layout) for session command"
        echo "  --hsplit               Create horizontal split (vertical layout) for session command"
        echo "  --create <path|name>   Create a project directory and switch to its session (tmux only)"
        echo "  --rename <path|name>   Rename current project directory and switch to updated session (tmux only)"
        echo "  --delete [path|name]   Delete a project directory (asks for confirmation, tmux only)"
        echo ""
        echo "Examples:"
        echo "  tmux-sessionizer --create my-project"
        echo "  tmux-sessionizer --rename ~/projects/new-name"
        echo "  tmux-sessionizer --delete"
        echo "  tmux-sessionizer --delete my-project"
        echo "  tmux-sessionizer -s 0 --vsplit"
        exit 0
        ;;
    -s | --session)
        session_idx="$2"
        if [[ -z $session_idx ]]; then
            echo "Session index cannot be empty"
            exit 1
        fi

        if [[ -z $TS_SESSION_COMMANDS ]]; then
            echo "TS_SESSION_COMMANDS is not set.  Must have a command set to run when switching to a session"
            exit 1
        fi

        if [[ -z "$session_idx" || "$session_idx" -lt 0 || "$session_idx" -ge "${#TS_SESSION_COMMANDS[@]}" ]]; then
            echo "Error: Invalid index. Please provide an index between 0 and $((${#TS_SESSION_COMMANDS[@]} - 1))."
            exit 1
        fi

        session_cmd="${TS_SESSION_COMMANDS[$session_idx]}"

        shift
        ;;
    --vsplit)
        split_type="vsplit"
        ;;
    --hsplit)
        split_type="hsplit"
        ;;
    --create)
        set_lifecycle_action "create"
        create_target="$2"
        if [[ -z "$create_target" || "$create_target" == -* ]]; then
            echo "Error: --create requires a path or project name"
            exit 1
        fi
        shift
        ;;
    --rename)
        set_lifecycle_action "rename"
        rename_target="$2"
        if [[ -z "$rename_target" || "$rename_target" == -* ]]; then
            echo "Error: --rename requires a new name or path"
            exit 1
        fi
        shift
        ;;
    --delete)
        set_lifecycle_action "delete"
        if [[ -n "$2" && "$2" != -* ]]; then
            delete_target="$2"
            shift
        fi
        ;;
    -v | --version)
        echo "tmux-sessionizer version $VERSION"
        exit 0
        ;;
    *)
        user_selected="$1"
        ;;
    esac
    shift
done

log "tmux-sessionizer($VERSION): idx=$session_idx cmd=$session_cmd user_selected=$user_selected split_type=$split_type log=$TS_LOG log_file=$TS_LOG_FILE"

# Validate split options are only used with session commands
if [[ -n "$split_type" && -z "$session_idx" ]]; then
    echo "Error: --vsplit and --hsplit can only be used with -s/--session option"
    exit 1
fi

if [[ -n "$lifecycle_action" && -n "$session_idx" ]]; then
    echo "Error: --create, --rename, and --delete cannot be combined with -s/--session"
    exit 1
fi

sanity_check() {
    if ! command -v tmux &>/dev/null; then
        echo "tmux is not installed. Please install it first."
        exit 1
    fi

    if ! command -v fzf &>/dev/null; then
        echo "fzf is not installed. Please install it first."
        exit 1
    fi
}

is_repo_url() {
    local input="$1"
    [[ "$input" == https://github.com/* || "$input" == git@github.com:* || "$input" == git@codeberg.org:* || "$input" == https://codeberg.org/* || "$input" == https://git.ufam.edu.br/* || "$input" == git@git.ufam.edu.br:* ]]
}

default_clone_dir() {
    local base
    if [[ -n "$TS_REPO_CLONE_DIR" ]]; then
        base="$TS_REPO_CLONE_DIR"
    elif [[ ${#TS_SEARCH_PATHS[@]} -gt 0 ]]; then
        base="${TS_SEARCH_PATHS[0]}"
        base="${base%%:*}"
    else
        base="$HOME"
    fi

    base="${base/#\~/$HOME}"
    printf '%s\n' "$base"
}

expand_path() {
    local path="$1"
    printf '%s\n' "${path/#\~/$HOME}"
}

resolve_base_relative_path() {
    local input="$1"
    if [[ "$input" == ~* || "$input" == /* ]]; then
        expand_path "$input"
        return
    fi

    local base
    base=$(default_clone_dir)
    printf '%s\n' "$base/$input"
}

current_project_dir() {
    local current_path
    if [[ -n "$TMUX" ]]; then
        current_path=$(tmux display-message -p '#{pane_current_path}' 2>/dev/null)
    fi

    if [[ -z "$current_path" ]]; then
        current_path="$PWD"
    fi

    printf '%s\n' "$(expand_path "$current_path")"
}

require_tmux_for_project_ops() {
    if [[ -z "$TMUX" ]]; then
        echo "Error: --create, --rename, and --delete must be run inside a tmux session"
        exit 1
    fi
}

resolve_rename_target_path() {
    local current_dir="$1"
    local target_input="$2"

    if [[ "$target_input" == ~* || "$target_input" == /* ]]; then
        expand_path "$target_input"
        return
    fi

    local current_parent
    current_parent=$(dirname "$current_dir")
    printf '%s\n' "$current_parent/$target_input"
}

session_name_from_path() {
    basename "$1" | tr . _
}

safe_delete_dir() {
    local target="$1"
    local resolved_target resolved_home

    if [[ -z "$target" ]]; then
        echo "Error: Refusing to delete an empty path"
        exit 1
    fi

    if [[ ! -d "$target" ]]; then
        echo "Error: '$target' is not a directory"
        exit 1
    fi

    resolved_target=$(cd "$target" && pwd -P)
    resolved_home=$(cd "$HOME" && pwd -P)

    if [[ -z "$resolved_target" || "$resolved_target" == "/" || "$resolved_target" == "$resolved_home" ]]; then
        echo "Error: Refusing to delete protected path '$resolved_target'"
        exit 1
    fi

    echo "Project directory to delete: $resolved_target"
    read -r -p "Delete project directory '$resolved_target'? [y/N]: " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Delete canceled"
        exit 0
    fi

    local target_session current_session
    target_session=$(session_name_from_path "$resolved_target")

    if [[ -n "$TMUX" ]]; then
        current_session=$(tmux display-message -p '#S' 2>/dev/null)
        if [[ -n "$current_session" && "$current_session" == "$target_session" ]]; then
            if ! tmux switch-client -n 2>/dev/null; then
                tmux detach-client
                echo "No other session found; detached client"
            else
                echo "Switched to next tmux session"
            fi
        fi
    fi

    if has_session "$target_session"; then
        tmux kill-session -t "$target_session"
        echo "Closed tmux session: $target_session"
    else
        echo "No tmux session found for: $target_session"
    fi

    if ! rm -r "$resolved_target"; then
        echo "Error: Failed to delete '$resolved_target'"
        exit 1
    fi

    echo "Project deleted: $resolved_target"
}

resolve_selected_target() {
    local input="$1"

    if [[ -d "$input" ]]; then
        selected="$input"
        return
    fi

    if has_session "$input"; then
        selected="$input"
        return
    fi

    if is_repo_url "$input"; then
        if ! command -v git &>/dev/null; then
            echo "git is not installed. Please install it first."
            exit 1
        fi

        local repo_name clone_base custom_target target_dir
        repo_name=$(basename "$input" .git)
        clone_base=$(default_clone_dir)
        clone_base="${clone_base/#\~/$HOME}"

        mkdir -p "$clone_base"

        echo "Cloning repo '$repo_name' to '$clone_base'."
        read -r -p "Clone destination (enter for '$clone_base/$repo_name'): " custom_target

        if [[ -z "$custom_target" ]]; then
            target_dir="$clone_base/$repo_name"
        elif [[ "$custom_target" == ~* || "$custom_target" == /* ]]; then
            target_dir="${custom_target/#\~/$HOME}"
        else
            target_dir="$clone_base/$custom_target"
        fi

        git clone "$input" "$target_dir"
        if [[ $? -ne 0 ]]; then
            echo "Failed to clone repository"
            exit 1
        fi

        echo "Repository cloned successfully to $target_dir"
        selected="$target_dir"
        return
    fi

    selected="$input"
}

switch_to() {
    if [[ -z $TMUX ]]; then
        log "attaching to session $1"
        tmux attach-session -t "$1"
    else
        log "switching to session $1"
        tmux switch-client -t "$1"
    fi
}

has_session() {
    tmux has-session -t="$1" 2>/dev/null
}

hydrate() {
    if [[ ! -z $session_cmd ]]; then
        log "skipping hydrate for $1 -- using \"$session_cmd\" instead"
        return
    elif [ -f "$2/.tmux-sessionizer" ]; then
        log "sourcing(local) $2/.tmux-sessionizer"
        tmux send-keys -t "$1" "source $2/.tmux-sessionizer" c-M
    elif [ -f "$HOME/.tmux-sessionizer" ]; then
        log "sourcing(global) $HOME/.tmux-sessionizer"
        tmux send-keys -t "$1" "source $HOME/.tmux-sessionizer" c-M
    fi
}

is_tmux_running() {
    tmux_running=$(pgrep tmux)

    if [[ -z $TMUX ]] && [[ -z $tmux_running ]]; then
        return 1
    fi
    return 0
}

init_pane_cache() {
    mkdir -p "$PANE_CACHE_DIR"
    touch "$PANE_CACHE_FILE"
}

get_pane_id() {
    local session_idx="$1"
    local split_type="$2"
    init_pane_cache
    grep "^${session_idx}:${split_type}:" "$PANE_CACHE_FILE" | cut -d: -f3
}

set_pane_id() {
    local session_idx="$1"
    local split_type="$2"
    local pane_id="$3"
    init_pane_cache

    # Remove existing entry if it exists
    grep -v "^${session_idx}:${split_type}:" "$PANE_CACHE_FILE" > "${PANE_CACHE_FILE}.tmp" 2>/dev/null || true
    mv "${PANE_CACHE_FILE}.tmp" "$PANE_CACHE_FILE"

    # Add new entry
    echo "${session_idx}:${split_type}:${pane_id}" >> "$PANE_CACHE_FILE"
}

cleanup_dead_panes() {
    init_pane_cache
    local temp_file="${PANE_CACHE_FILE}.tmp"

    while IFS=: read -r idx split pane_id; do
        if tmux list-panes -a -F "#{pane_id}" 2>/dev/null | grep -q "^${pane_id}$"; then
            echo "${idx}:${split}:${pane_id}" >> "$temp_file"
        fi
    done < "$PANE_CACHE_FILE"

    mv "$temp_file" "$PANE_CACHE_FILE" 2>/dev/null || touch "$PANE_CACHE_FILE"
}

sanity_check

# if TS_SEARCH_PATHS is not set use default
[[ -n "$TS_SEARCH_PATHS" ]] || TS_SEARCH_PATHS=(~/ ~/personal ~/personal/dev/env/.config)

# Add any extra search paths to the TS_SEARCH_PATHS array
# e.g : EXTRA_SEARCH_PATHS=("$HOME/extra1:4" "$HOME/extra2")
# note : Path can be suffixed with :number to limit or extend the depth of the search for the Path

if [[ ${#TS_EXTRA_SEARCH_PATHS[@]} -gt 0 ]]; then
    TS_SEARCH_PATHS+=("${TS_EXTRA_SEARCH_PATHS[@]}")
fi

if [[ -n "$lifecycle_action" ]]; then
    require_tmux_for_project_ops
fi

if [[ "$lifecycle_action" == "create" ]]; then
    selected=$(resolve_base_relative_path "$create_target")
    if [[ -e "$selected" && ! -d "$selected" ]]; then
        echo "Error: '$selected' exists and is not a directory"
        exit 1
    fi

    mkdir -p "$selected"
elif [[ "$lifecycle_action" == "rename" ]]; then
    old_selected=$(current_project_dir)
    if [[ ! -d "$old_selected" ]]; then
        echo "Error: Current project directory '$old_selected' does not exist"
        exit 1
    fi

    selected=$(resolve_rename_target_path "$old_selected" "$rename_target")
    if [[ -z "$selected" ]]; then
        echo "Error: Invalid rename target"
        exit 1
    fi

    old_session_name=$(session_name_from_path "$old_selected")
    selected=$(expand_path "$selected")

    if [[ "$old_selected" != "$selected" ]]; then
        if [[ -e "$selected" ]]; then
            echo "Error: Rename target '$selected' already exists"
            exit 1
        fi

        mv "$old_selected" "$selected"
    fi

    new_session_name=$(session_name_from_path "$selected")
    if [[ "$old_session_name" != "$new_session_name" ]] && has_session "$old_session_name"; then
        tmux rename-session -t "$old_session_name" "$new_session_name"
    fi
elif [[ "$lifecycle_action" == "delete" ]]; then
    if [[ -n "$delete_target" ]]; then
        selected=$(resolve_base_relative_path "$delete_target")
    else
        selected=$(current_project_dir)
    fi

    safe_delete_dir "$selected"
    exit 0
fi

# utility function to find directories
find_dirs() {
    # list TMUX sessions
    if [[ -n "${TMUX}" ]]; then
        current_session=$(tmux display-message -p '#S')
        tmux list-sessions -F "#{session_name}" 2>/dev/null | grep -vFx "$current_session" | while IFS= read -r name; do
            printf '%s\t[TMUX] %s\n' "$name" "$name"
        done
    else
        tmux list-sessions -F "#{session_name}" 2>/dev/null | while IFS= read -r name; do
            printf '%s\t[TMUX] %s\n' "$name" "$name"
        done
    fi

    # note: TS_SEARCH_PATHS is an array of paths to search for directories
    # if the path ends with :number, it will search for directories with a max depth of number ;)
    # if there is no number, it will search for directories with a max depth defined by TS_MAX_DEPTH or 1 if not set
    for entry in "${TS_SEARCH_PATHS[@]}"; do
        # Check if entry as :number as suffix then adapt the maxdepth parameter
        if [[ "$entry" =~ ^([^:]+):([0-9]+)$ ]]; then
            path="${BASH_REMATCH[1]}"
            depth="${BASH_REMATCH[2]}"
        else
            path="$entry"
        fi

        if [[ -d "$path" ]]; then
            local resolved_path
            resolved_path=$(cd "$path" && pwd)
            find "$resolved_path" -mindepth 1 -maxdepth "${depth:-${TS_MAX_DEPTH:-1}}" -path '*/.git' -prune -o -type d -print | while IFS= read -r dir; do
                local session_name
                session_name=$(basename "$dir" | tr . _)
                if tmux has-session -t="$session_name" 2>/dev/null; then
                    continue
                fi
                local relative="${dir#"$resolved_path"/}"
                printf '%s\t%s\n' "$dir" "$relative"
            done
        fi
    done
}

handle_session_cmd() {
    log "executing session command $session_cmd with index $session_idx split_type=$split_type"
    if ! is_tmux_running; then
        echo "Error: tmux is not running.  Please start tmux first before using session commands."
        exit 1
    fi

    current_session=$(tmux display-message -p '#S')

    if [[ -n "$split_type" ]]; then
        handle_split_session_cmd "$current_session"
    else
        handle_window_session_cmd "$current_session"
    fi
    exit 0
}

handle_window_session_cmd() {
    local current_session="$1"
    start_index=$((69 + session_idx))
    target="$current_session:$start_index"

    log "target: $target command $session_cmd has-session=$(tmux has-session -t="$target" 2> /dev/null)"
    if tmux has-session -t="$target" 2> /dev/null; then
        switch_to "$target"
    else
        log "executing session command: tmux neww -dt $target $session_cmd"
        tmux neww -dt "$target" "$session_cmd"
        hydrate "$target" "$selected"
        tmux select-window -t "$target"
    fi
}

handle_split_session_cmd() {
    local current_session="$1"
    cleanup_dead_panes

    # Check if pane already exists
    local existing_pane_id
    existing_pane_id=$(get_pane_id "$session_idx" "$split_type")

    if [[ -n "$existing_pane_id" ]] && tmux list-panes -a -F "#{pane_id}" 2>/dev/null | grep -q "^${existing_pane_id}$"; then
        log "switching to existing pane $existing_pane_id"
        tmux select-pane -t "$existing_pane_id"
        if [[ -z $TMUX ]]; then
            tmux attach-session -t "$current_session"
        else
            tmux switch-client -t "$current_session"
        fi
    else
        # Create new split
        local split_flag=""
        if [[ "$split_type" == "vsplit" ]]; then
            split_flag="-h"  # horizontal layout (vertical split)
        else
            split_flag="-v"  # vertical layout (horizontal split)
        fi

        log "creating new split: tmux split-window $split_flag -c $(pwd) $session_cmd"
        local new_pane_id
        new_pane_id=$(tmux split-window $split_flag -c "$(pwd)" -P -F "#{pane_id}" "$session_cmd")

        if [[ -n "$new_pane_id" ]]; then
            set_pane_id "$session_idx" "$split_type" "$new_pane_id"
            log "created pane $new_pane_id for session_idx=$session_idx split_type=$split_type"
        fi
    fi
}

if [[ ! -z $session_cmd ]]; then
    handle_session_cmd
elif [[ -n "$lifecycle_action" ]]; then
    :
elif [[ ! -z $user_selected ]]; then
    selected="$user_selected"
else
    selected_output=$(find_dirs | fzf --delimiter=$'\t' --with-nth=2 --print-query)
    selected="${selected_output##*$'\n'}"
fi

if [[ -z $selected ]]; then
    exit 0
fi

# extract fullpath/session name (column 1) from TAB-delimited fzf output
selected=$(printf '%s' "$selected" | cut -f1)

resolve_selected_target "$selected"

selected_name=$(basename "$selected" | tr . _)

if ! is_tmux_running; then
    tmux new-session -ds "$selected_name" -c "$selected"
    hydrate "$selected_name" "$selected"
fi

if ! has_session "$selected_name"; then
    tmux new-session -ds "$selected_name" -c "$selected"
    hydrate "$selected_name" "$selected"
fi

switch_to "$selected_name"
