#!/usr/bin/env bash

set -euo pipefail

# Credits:
# This script is based on, and inspired by, BreadOnPenguins' dmenu_cliphist:
# https://github.com/BreadOnPenguins/scripts/blob/master/dmenu_cliphist

histfile="${HOME}/.cache/cliphist"
placeholder=$'\x01NEWLINE\x01'
POLL_INTERVAL="${POLL_INTERVAL:-1}"

# Dependency checks
check_dependencies() {
  local missing=()
  command -v xclip >/dev/null 2>&1 || missing+=("xclip")
  command -v dmenu >/dev/null 2>&1 || missing+=("dmenu")

  if [ ${#missing[@]} -gt 0 ]; then
    printf "Error: Missing required dependencies: %s\n" "${missing[*]}" >&2
    exit 1
  fi

  # Check for notify-send availability
  if command -v notify-send >/dev/null 2>&1; then
    HAS_NOTIFY_SEND=1
  else
    HAS_NOTIFY_SEND=0
  fi
}

# Get reverse command (tac for Linux, tail -r for BSD/macOS)
get_reverse_cmd() {
  if command -v tac >/dev/null 2>&1; then
    printf "tac"
  else
    printf "tail -r"
  fi
}

# Safe file creation with atomic operation
ensure_histfile() {
  if [ ! -f "$histfile" ]; then
    mkdir -p "$(dirname "$histfile")"
    touch "$histfile"
    [ "$HAS_NOTIFY_SEND" -eq 1 ] && notify-send "Creating $histfile"
  fi
}

# Send notification if notify-send is available
notify() {
  local message="$1"
  if [ "$HAS_NOTIFY_SEND" -eq 1 ]; then
    notify-send -t 1000 "Clipboard Manager" "$message"
  fi
}

# Replace newlines with placeholder
escape_newlines() {
  local input="$1"
  printf '%s' "$input" | sed ':a;N;$!ba;s/\n/'"$placeholder"'/g'
}

# Replace placeholder with newlines
unescape_newlines() {
  local input="$1"
  printf '%s' "$input" | sed "s/$placeholder/\n/g"
}

highlight() {
  local clip
  clip=$(xclip -o -selection primary 2>/dev/null) || {
    printf "Error: Failed to read from primary selection\n" >&2
    exit 1
  }
  printf '%s' "$clip" | xclip -i -f -selection clipboard 2>/dev/null || {
    printf "Error: Failed to write to clipboard\n" >&2
    exit 1
  }
  printf '%s' "$clip"
}

output() {
  local clip
  clip=$(cat) || {
    printf "Error: Failed to read from stdin\n" >&2
    exit 1
  }
  printf '%s' "$clip" | xclip -i -f -selection clipboard 2>/dev/null || {
    printf "Error: Failed to write to clipboard\n" >&2
    exit 1
  }
  printf '%s' "$clip"
}

write() {
  local clip="$1"
  local multiline

  [ -z "$clip" ] && return 0

  ensure_histfile
  multiline=$(escape_newlines "$clip")

  if ! grep -Fxq "$multiline" "$histfile"; then
    printf '%s\n' "$multiline" >> "$histfile"
  fi

  printf '%s' "$(escape_newlines "$clip")"
}

# Watch mode - monitor clipboard for changes
watch_mode() {
  local poll_interval="${POLL_INTERVAL:-1}"
  local last_content=""

  while true; do
    local current
    current=$(xclip -o -selection clipboard 2>/dev/null) || true

    if [[ "$current" != "$last_content" ]] && [[ -n "$current" ]]; then
      write "$current"
      last_content="$current"
    fi

    sleep "$poll_interval"
  done
}

# Cleanup on exit
cleanup() {
  notify "Clipboard monitoring stopped"
  exit 0
}

# Trap signals for graceful shutdown
trap cleanup SIGTERM SIGINT

sel() {
  local reverse_cmd
  local selection
  local restored

  reverse_cmd=$(get_reverse_cmd)

  selection=$($reverse_cmd "$histfile" | dmenu -l 5 -p "Clipboard history:") || {
    printf "Error: Failed to open dmenu\n" >&2
    exit 1
  }

  if [ -n "$selection" ]; then
    restored=$(unescape_newlines "$selection")
    printf '%s' "$restored" | xclip -i -selection clipboard 2>/dev/null || {
      printf "Error: Failed to write to clipboard\n" >&2
      exit 1
    }
    printf '%s' "Copied to clipboard!"
  fi
}

# Main
check_dependencies

case "${1:-}" in
  add)
    clip=$(highlight)
    notification=$(write "$clip")
    ;;
  out)
    clip=$(output)
    notification=$(write "$clip")
    ;;
  sel)
    notification=$(sel)
    ;;
  watch)
    ensure_histfile
    notify "Starting clipboard monitoring..."
    watch_mode
    ;;
  *)
    printf "%s | File: %s\n\nadd - copies primary selection to clipboard, and adds to history file\nout - pipe commands to copy output to clipboard, and add to history file\nsel - select from history file with dmenu and recopy!\nwatch - monitor clipboard for changes automatically\n" "$0" "$histfile"
    exit 0
    ;;
esac

if [ -n "$notification" ] && [ "$HAS_NOTIFY_SEND" -eq 1 ]; then
  notify-send "$notification"
fi
