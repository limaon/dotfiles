#!/usr/bin/env bash
# Screen recording utility with dmenu selection
# Usage:
#   $0            - Ask for recording type via dmenu
#   $0 screencast - Record both audio and screen
#   $0 video      - Record only screen
#   $0 audio      - Record only audio
#   $0 kill       - Kill existing recording
#
# If there is already a running instance, user will be prompted to end it.
# https://trac.ffmpeg.org/wiki/Encode/H.264

set -euo pipefail

# Dependency check
for cmd in ffmpeg dmenu xrandr pactl notify-send; do
  command -v "$cmd" >/dev/null 2>&1 || {
    echo "Error: '$cmd' not found"
    exit 1
  }
done

# Use XDG_RUNTIME_DIR for temp files (safer than /tmp)
readonly RUNTIME_DIR="${XDG_RUNTIME_DIR:-/tmp}"
readonly PID_FILE="${RUNTIME_DIR}/recordingpid"
readonly ICON_FILE="${RUNTIME_DIR}/recordingicon"

die() {
  notify-send -u critical "${0##*/}" "$*" &
  echo "$*" >&2
  exit 1
}

if ! xrandr | grep -qF 'connected primary'; then
  die "No primary display assigned"
fi

dest_dir=$(xdg-user-dir VIDEOS)
readonly dest_dir
if [[ -z "$dest_dir" ]] || [[ ! -d "$dest_dir" ]]; then
  die "Can't find the Videos directory."
fi

screen_resolution() {
  xrandr | grep -Po 'connected primary \K[^ ]*?(?=\+)'
}

screen_offset() {
  xrandr | grep -Po 'connected primary [^ ]*?\+\K[^ ]*' | sed 's/+/,/'
}

notify_end() {
  notify-send "$(basename -- "$0")" "Stopped recording."
}

updateicon() {
  echo "$1" > "$ICON_FILE"
  pkill -RTMIN+9 "${STATUSBAR:-i3blocks}"
}

timestamp() {
  date -u '+%Y-%b-%d_%H-%M-%S'
}

killrecording() {
  [[ -f "$PID_FILE" ]] || return 0

  local recpid
  recpid=$(cat -- "$PID_FILE")
  [[ -z "$recpid" ]] && return 0

  # Kill with SIGTERM, allowing finishing touches
  kill -15 "$recpid" 2>/dev/null || true
  rm -f -- "$PID_FILE"
  updateicon ""

  # Wait for graceful shutdown, then force kill if needed
  sleep 3
  if kill -0 "$recpid" 2>/dev/null; then
    kill -9 "$recpid" 2>/dev/null || true
  fi

  notify_end
  exit 0
}

trim_spaces() {
  sed 's/^ *//g; s/ *$//g;'
}

find_monitor() {
  # Try to find monitor/speaker source, fallback to default
  pactl list sources 2>/dev/null |
    grep -i -B 1 -P 'Description:.*monitor|Description:.*speaker' |
    grep 'Name:' |
    head -1 |
    cut -d: -f2 |
    trim_spaces
}

find_microphone() {
  # Try to find microphone source, fallback to default
  pactl list sources 2>/dev/null |
    grep -i -B 1 -P 'Description:.*microphone|Description:.*mic' |
    grep 'Name:' |
    head -1 |
    cut -d: -f2 |
    trim_spaces
}

__ffmpeg() {
  local -r input=${1:?}
  local -r video_resolution=${2:?}
  local -r output=${3:?}

  local -r PA_MONITOR=$(find_monitor)
  local -r PA_MIC=$(find_microphone)

  local -a inputs=()
  if [[ -n "$PA_MONITOR" ]]; then
    inputs+=(-f pulse -thread_queue_size 1024 -i "$PA_MONITOR")
  else
    die "Monitor audio source not found."
  fi

  if [[ -n "$PA_MIC" ]]; then
    inputs+=(-f pulse -thread_queue_size 1024 -i "$PA_MIC")
    inputs+=(-filter_complex "[1:a][2:a]amix=inputs=2:duration=longest:dropout_transition=0[aout]")
    inputs+=(-map "[aout]")
  else
    inputs+=(-map "1:a")
  fi

  exec ffmpeg -y \
    -f x11grab \
    -framerate 30 \
    -s "$video_resolution" \
    -i "$input" \
    -use_wallclock_as_timestamps 1 \
    "${inputs[@]}" \
    -map 0:v \
    -r 30 \
    -c:v libx264 \
    -crf 10 \
    -preset ultrafast \
    -c:a aac \
    -b:a 256k \
    -ac 2 \
    -qp 0 \
    -profile:v baseline \
    -movflags +faststart \
    -pix_fmt yuv420p \
    -vf "pad=ceil(iw/2)*2:ceil(ih/2)*2" \
    "$output"
}

screencast() {
  __ffmpeg "$DISPLAY+$(screen_offset)" "$(screen_resolution)" "$dest_dir/screencast-$(timestamp).mp4" &
  echo $! > "$PID_FILE"
  updateicon "REC"
}

selected_area() {
  command -v slop >/dev/null 2>&1 || die "slop not installed"
  local X Y W H
  read -r X Y W H <<<"$(slop -f "%x %y %w %h")"
  __ffmpeg "${DISPLAY}+${X},${Y}" "${W}x${H}" "$dest_dir/screencast-area-$(timestamp).mp4" &
  echo $! > "$PID_FILE"
  updateicon "REC"
}

video() {
  ffmpeg \
    -an \
    -f x11grab \
    -framerate 30 \
    -s "$(screen_resolution)" \
    -i "$DISPLAY+$(screen_offset)" \
    -c:v libx264 \
    -qp 0 \
    -r 30 \
    -pix_fmt yuv420p \
    -vf "pad=ceil(iw/2)*2:ceil(ih/2)*2" \
    -movflags +faststart \
    -profile:v baseline \
    "$dest_dir/video-$(timestamp).mkv" &
  echo $! > "$PID_FILE"
  updateicon "REC"
}

webcam() {
  local -r device="${1:-/dev/video0}"
  local -r resolution="${2:-640x480}"

  [[ -e "$device" ]] || die "Webcam not found: $device"

  ffmpeg \
    -f v4l2 \
    -i "$device" \
    -s "$resolution" \
    "$dest_dir/webcam-$(timestamp).mkv" &
  echo $! > "$PID_FILE"
  updateicon "CAM"
}

webcamhidef() {
  webcam "/dev/video0" "1920x1080"
}

audio() {
  local -r file_path="$dest_dir/audio-$(timestamp).flac"
  ffmpeg \
    -f alsa -i default \
    -c:a flac \
    "$file_path" &
  echo $! > "$PID_FILE"
  updateicon "MIC"
}

dmenu_recording_style() {
  cat <<-EOF | dmenu -l 30 -i -p "Select recording style:"
		screencast
		video
		audio
		webcam
		webcam (hi-def)
		selected area
	EOF
}

askrecording() {
  case "$(dmenu_recording_style)" in
    'screencast') screencast ;;
    'video') video ;;
    'audio') audio ;;
    'webcam') webcam ;;
    'webcam (hi-def)') webcamhidef ;;
    'selected area') selected_area ;;
  esac
}

asktoend() {
  local -r response=$(printf "No\\nYes" | dmenu -i -p "Recording still active. End recording?")
  if [[ "$response" = "Yes" ]]; then
    killrecording
  fi
}

case "${1-}" in
  screencast) screencast ;;
  audio) audio ;;
  video) video ;;
  selected*) selected_area ;;
  kill) killrecording ;;
  *)
    if [[ -f "$PID_FILE" ]]; then
      asktoend
      exit
    else
      askrecording
    fi
    ;;
esac
